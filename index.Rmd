---
title: "Sharing your method with R(cpp)"
subtitle: "Four guidelines for faster code"
author: "Byron C Jaeger"
institute: "Wake Forest University School of Medicine"
date: "2022/08/08 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
class: center, middle

```{r setup, include=FALSE}

options(htmltools.dir.version = FALSE)

library(magrittr)
library(gt)
library(dplyr)
library(purrr)
library(ggplot2)
library(Rcpp)
library(microbenchmark)
library(ggridges)
library(table.glue)
library(readr)


gg_data <- read_rds("time_fig_data.rds") %>% 
 mutate(
  model = recode(
   model,
   'obliqueRSF-net' = 'obliqueRSF',
   'aorsf-fast' = 'aorsf',
   'rsf-standard' = 'randomForestSRC',
   'ranger-extratrees' = 'ranger',
   'cif-standard' = 'party'
  )
 )

medians <- read_rds("time_fig_medians.rds") %>% 
 mutate(
  model = recode(
   model,
   'obliqueRSF-net' = 'obliqueRSF',
   'aorsf-fast' = 'aorsf',
   'rsf-standard' = 'randomForestSRC',
   'ranger-extratrees' = 'ranger',
   'cif-standard' = 'party'
  ),
  color = recode(
   model,
   'obliqueRSF' = 'black',
   'aorsf' = 'white',
   'randomForestSRC' = 'white',
   'ranger' = 'white',
   'party' = 'black'
  )
 ) %>% 
 mutate(vjust = -0.25)

fig_subsets <- list(
 slide_one = c('obliqueRSF', 
               'randomForestSRC',
               'ranger', 
               'party'),
 slide_two = c('obliqueRSF', 
               'aorsf', 
               'randomForestSRC',
               'ranger', 
               'party')
)

fig_worker <- function(data, medians){

  fig <- ggplot(data) +
    aes(x = time, y = reorder(model, time, FUN=median),
        fill = model) +
    stat_density_ridges(
      quantile_lines = TRUE,
      quantiles = 0.5,
      bandwidth = 0.2,
      scale = 1
    ) +
    scale_x_log10(
      breaks = c(0.01, 0.1, 1, 10, 100, 1000, 10000),
      labels = c("0.01", "0.1", "1", "10", "100", "1,000", "10,000"),
      expand = c(0,0)
    ) +
    geom_text(
      data = medians,
      hjust = medians$hjust,
      vjust = medians$vjust,
      color = medians$color,
      aes(label = table_glue("{time}s"))
    ) +
    scale_fill_viridis_d() +
    theme_minimal() +
    theme(panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank(),
          legend.position = '') +
    labs(x = 'Time to fit a model and compute predictions, seconds',
         y = '')


}

figs <- fig_subsets %>%
    map(
      ~ fig_worker(
        data = filter(gg_data, model %in% .x),
        medians = filter(medians, model %in% .x)
      )
    )



# draw with pencil on slides
# xaringanExtra::use_scribble()

# freeze gifs till you are on their slide
# xaringanExtra::use_freezeframe()

```

```{r, echo = FALSE}

# to make sourceCpp work from rmd
Sys.setenv(PATH = paste(Sys.getenv("PATH"), "C:\\rtools40\\usr\\bin", sep = ";"))
sourceCpp("src/count_events.cpp")

```



```{r xaringan-banner, echo=FALSE}

xaringanExtra::use_banner(
 top_left = "Sharing methods with R(cpp)",
 top_right = "Byron C Jaeger",
 bottom_left = "https://bcjaeger.github.io/seminar-fastpack/",
 exclude = c("inverse")
)

```


# What do biostatisticians do?

---
class: center, middle

# 1. Create methods that can engage with contemporary data and make valid conclusions

---
class: center, middle

# 2. Share those methods

---
class: center, middle

# 3. - ??? many other things...

---
## Graduate training

- Number of required courses on statistics and probability: 4+

--

- Number of required courses on software development: ???

So how do most of us learn?

---
background-image: url("img/meme_software_books.jpg")
background-size: 61%

---
## obliqueRSF

In 2019, I made the `obliqueRSF` R package

- oblique random survival forests

--

`obliqueRSF` had higher prediction accuracy versus:

- `randomForestSRC`, 

- `ranger`,

- `party`. 

- but was also hundreds of times slower.

---
class: center, middle
background-image: url("img/meme_slow_R.jpg")
background-size: contain

---

```{r, fig.height = 6.5, fig.width = 8, echo = FALSE, dpi = 300}
figs$slide_one
```

---

```{r, fig.height = 6.5, fig.width = 8, echo = FALSE, dpi = 300}
figs$slide_two
```

---
class: center, middle, inverse

# Four guidelines for faster code 

---
class: center, middle

# 1. Always be benchmarking

---
## Why benchmark?

- it gives you data on how fast your code runs

--

- it encourages you to write more modular functions (a good thing)


---
## How to benchmark?

__Step 1. Define a task:__ Count events per group (status of 1 $\Rightarrow$ event, 3 groups)

```{r}

# status = c(1, 0, 1, ...)
status = sample(x = c(0L, 1L), size = 1e5, replace = TRUE)

# group = c(2, 0, 1, ...)
group = sample(x = c(0L, 1L, 2L), size = 1e5, replace = TRUE)

```

--

__Step 2. Define the reference competitors__

```{r}

# competitors: table() and tapply()
table(status, group)[2, ] 

tapply(status, group, FUN = sum)

```

---

## How to benchmark?

__Step 2 contd.__ Enter your own competitor(s)!

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_1.png')
```

---

## How to benchmark?

__Step 2 contd.__ Enter your own competitor(s)!

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_2.png')
```

---

## How to benchmark?

__Step 2 contd.__ Enter your own competitor(s)!

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_3.png')
```


---

## How to benchmark?

__Step 2 contd.__ Enter your own competitor(s)!

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_4.png')
```


---

## How to benchmark?

__Step 2 contd.__ Enter your own competitor(s)!

```{Rcpp, eval = FALSE}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector rcpp_count_dbl(NumericVector status,
                             NumericVector group,
                             int n_groups) {

 NumericVector out(n_groups);

 for( int i = 0; i < n_groups; i++ ){
  for( int j = 0; j < group.length(); j++ ){
   if(group[j] == i) out[i] += status[j];
  }
 }

 return(out);
}


```

---

## How to benchmark?

__Step 3. Off to the races:__

```{r, eval = FALSE}
library(microbenchmark)
microbenchmark(table = table(status, group)[2, ],
               tapply = tapply(status, group, FUN = sum),
               rcpp_count_dbl = rcpp_count_dbl(status, group, 3))
```

--

```{r, echo = FALSE}

library(table.glue)

bm <- readr::read_rds('benchmark.rds')

tbl_1 <- summary(bm) %>%
 select(-cld, -neval) %>%
 filter(expr %in% c("table",
                    "tapply",
                    "rcpp_count_dbl")) %>% 
 mutate(across(where(is.numeric), ~table_value(.x/1000))) %>%
 gt(rowname_col = 'expr') %>%
 tab_header(
  title = "Benchmark demonstration: counting events in groups",
  subtitle = "table(), tapply(), and rcpp_count_dbl()"
 ) %>%
 cols_label(min = 'Minimum',
            lq = '25th %',
            mean = 'Mean',
            median = 'Median',
            uq = '75th %',
            max = 'Maximum') %>%
 cols_align('center') %>%
 tab_stubhead(label = 'Function') %>%
 tab_spanner(columns = c("min", "lq", "mean", "median", "uq", "max"),
             label = "Time, milliseconds") %>% 
 tab_style(
  style = list(
   cell_fill(color = "#F9E3D6"),
   cell_text(style = "italic")
  ),
  locations = cells_body(
   columns = median
  )
 )

tbl_1

```


---
class: center, middle

# 2. Trace your data

---
## What do you mean by trace?

Tracing your data means being notified when 

- your data are copied

--

- your data are cast to a different type

--

## So, why trace?

Copying and casting require additional memory, slowing down your code.

---
## How to trace?

```{r}
tracemem(status)
tracemem(group)
```

Now, R will yell at me if data in `status` or `group` are copied or cast to a different type. 

---
## So, who's copying data?

`table` makes no copies

```{r}
table(status, group)
```


---
## So, who's copying data?

`tapply` copies the `group` data

```{r}
tapply(status, group, sum)
```

---
## So, who's copying data?

`rcpp_count_dbl` casts both vectors from integer to double

```{r}
rcpp_count_dbl(status, group, n_groups = 3)
```

---
## Let's fix that

```{Rcpp, eval = FALSE}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
IntegerVector rcpp_count_int(IntegerVector status,
                             IntegerVector group,
                             int n_groups) {

 IntegerVector out(n_groups);

 for( int i = 0; i < n_groups; i++ ){
  for( int j = 0; j < group.length(); j++ ){
   if(group[j] == i) out[i] += status[j];
  }
 }

 return(out);
}

```


---
## So, who's copying data?

`rcpp_count_int` makes no copies

```{r}
rcpp_count_int(status, group, n_groups = 3)
```

---
class: center, middle

## Better!

```{r, echo = FALSE}

tbl_2 <- summary(bm) %>%
 select(-cld, -neval) %>%
 filter(expr %in% c("table",
                    "tapply",
                    "rcpp_count_dbl",
                    "rcpp_count_int")) %>% 
 mutate(across(where(is.numeric), ~table_value(.x/1000))) %>%
 gt(rowname_col = 'expr') %>%
 tab_header(
  title = "Benchmark demonstration: counting events in groups",
  subtitle = "table(), tapply(), and Rcpp functions"
 ) %>%
 cols_label(min = 'Minimum',
            lq = '25th %',
            mean = 'Mean',
            median = 'Median',
            uq = '75th %',
            max = 'Maximum') %>%
 cols_align('center') %>%
 tab_stubhead(label = 'Function') %>%
 tab_spanner(columns = c("min", "lq", "mean", "median", "uq", "max"),
             label = "Time, milliseconds") %>% 
 tab_style(
  style = list(
   cell_fill(color = "#F9E3D6"),
   cell_text(style = "italic")
  ),
  locations = cells_body(
   columns = median
  )
 )

tbl_2

```

---
class: center, middle

# 3. Count your operations

---
## Why count operations?

Number of operations $\approx$ computational cost of your code

## How to count

You don't have to be exact, just write the main ideas 

---
## Example

In our C++ function, we use $n$ operations for each unique value in `group`, 

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_1.png')
```

---
## Example

In our C++ function, we use $n$ operations for each unique value in `group`, 


```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_2.png')
```

---
## Example

In our C++ function, we use $n$ operations for each unique value in `group`, 

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_3.png')
```

---
## Example

In our C++ function, we use $n$ operations for each unique value in `group`, 

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_4.png')
```

---
## Example

As $n, g \rightarrow \infty$, we use $\mathcal{O}(n \cdot g)$ operations, where $g$ = number of groups

Can we reduce the operation cost?

- Can't remove the sum, so we have at least $n$ operations.

- Can we sum by group without finding group indices? That would drop $g$ from our operation count

Yes, because the group indices are given to us by the group vector.

---
## 1 loop instead of 2

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_5.png')
```

---
## 1 loop instead of 2

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_6.png')
```

---
## 1 loop instead of 2

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_7.png')
```

---
## 1 loop instead of 2

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_8.png')
```

---
## 1 loop instead of 2

```{r, echo = FALSE}
knitr::include_graphics('ink/vecs_9.png')
```

---

```{Rcpp, eval = FALSE}

#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
IntegerVector rcpp_count_1loop_int(IntegerVector status,
                                   IntegerVector group,
                                   int n_groups) {

 IntegerVector out(n_groups);

 IntegerVector::iterator i;

 int j = 0;

 for(i = group.begin() ; i != group.end(); ++i, ++j){

  out[*i] += status[j];

 }

 return(out);

}

```


---
class: center, middle

## Much better!

```{r, echo = FALSE}

tbl_2 <- summary(bm) %>%
 select(-cld, -neval) %>%
 filter(expr %in% c("table",
                    "tapply",
                    "rcpp_count_dbl",
                    "rcpp_count_int",
                    "rcpp_count_1loop_int")) %>% 
 mutate(across(where(is.numeric), ~table_value(.x/1000))) %>%
 gt(rowname_col = 'expr') %>%
 tab_header(
  title = "Benchmark demonstration: counting events in groups",
  subtitle = "table(), tapply(), and Rcpp functions"
 ) %>%
 cols_label(min = 'Minimum',
            lq = '25th %',
            mean = 'Mean',
            median = 'Median',
            uq = '75th %',
            max = 'Maximum') %>%
 cols_align('center') %>%
 tab_stubhead(label = 'Function') %>%
 tab_spanner(columns = c("min", "lq", "mean", "median", "uq", "max"),
             label = "Time, milliseconds") %>% 
 tab_style(
  style = list(
   cell_fill(color = "#F9E3D6"),
   cell_text(style = "italic")
  ),
  locations = cells_body(
   columns = median
  )
 )

tbl_2

```


---
class: center, middle

# 4. Ride the Armadillo 

---
background-image: url("img/meme_aorsf_car.png")
background-size: 65%

---

## Armadillo

(http://arma.sourceforge.net/)

```{r out.width='100%', echo = FALSE}

knitr::include_url("http://arma.sourceforge.net/")

```

---
## Armadillo

```{Rcpp, eval = FALSE}
#include <RcppArmadillo.h>
#include <RcppArmadilloExtensions/sample.h>
// [[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;

// [[Rcpp::export]]
arma::ivec arma_count_1loop_int(arma::ivec& status,
                                arma::ivec& group,
                                arma::uword n_groups) {

 ivec out(n_groups);
 ivec::iterator i;
 uword j = 0;

 for(i = group.begin() ; i != group.end(); ++i, ++j){
  out[*i] += status[j];
 }

 return(out);

}

```

---
class: center, middle

## Better! (almost perfect)

```{r, echo = FALSE}

tbl_3 <- summary(bm) %>%
 select(-cld, -neval) %>%
 mutate(across(where(is.numeric), ~table_value(.x/1000))) %>%
 gt(rowname_col = 'expr') %>%
 tab_header(
  title = "Benchmark demonstration: counting events in groups",
  subtitle = "table(), tapply(), and Rcpp functions"
 ) %>%
 cols_label(min = 'Minimum',
            lq = '25th %',
            mean = 'Mean',
            median = 'Median',
            uq = '75th %',
            max = 'Maximum') %>%
 cols_align('center') %>%
 tab_stubhead(label = 'Function') %>%
 tab_spanner(columns = c("min", "lq", "mean", "median", "uq", "max"),
             label = "Time, milliseconds") %>% 
 tab_style(
  style = list(
   cell_fill(color = "#F9E3D6"),
   cell_text(style = "italic")
  ),
  locations = cells_body(
   columns = median
  )
 )

tbl_3

```

